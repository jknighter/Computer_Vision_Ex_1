# -*- coding: utf-8 -*-
"""01_gaussian_filtering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uVfO_TWiXNZsNLS3J3d0h-uCsfpJNvD-

# Gaussian Filtering
In the following, you will implement a method which generates and applies a Gaussian filter for a given variance and number of samples.
"""

# %matplotlib notebook
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
a = np.array([])
a = np.append(a, [[1, 2, 3], [2, 3, 2]])
b = np.array(3)
print(b.shape)

"""## Some convenience functions"""

def imread_rgb(filename):
    """Read a color image from our data directory."""
    im = cv2.imread(f'../data/{filename}')
    im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)
    return im


def plot_multiple(images, titles, colormap='gray', max_columns=np.inf, share_axes=True):
    """Plot multiple images as subplots on a grid."""
    assert len(images) == len(titles)
    n_images = len(images)
    n_cols = min(max_columns, n_images)
    n_rows = int(np.ceil(n_images / n_cols))
    fig, axes = plt.subplots(
        n_rows, n_cols, figsize=(n_cols * 4, n_rows * 4),
        squeeze=False, sharex=share_axes, sharey=share_axes)

    axes = axes.flat
    # Hide subplots without content
    for ax in axes[n_images:]:
        ax.axis('off')
        
    if not isinstance(colormap, (list,tuple)):
        colormaps = [colormap]*n_images
    else:
        colormaps = colormap

    for ax, image, title, cmap in zip(axes, images, titles, colormaps):
        ax.imshow(image, cmap=cmap)
        ax.set_title(title)
        
    fig.tight_layout()

"""## Part a
Start by writing a function ``gauss`` which creates a 1D Gaussian from a given vector of integer indices $\mathtt{x = [-w, \ldots, w]}$:
$$
    \mathtt{G[i]} = \frac{1}{\sqrt{2\pi}\sigma}\operatorname{exp}\biggl(-\frac{\mathtt{x[i]}^2}{2\sigma^2}\biggr)
$$
where $\sigma$ is the standard deviation.
"""



def gauss(x, sigma):
    # Your code here
    x = 1/(np.sqrt(2*np.pi)*sigma)*np.power(np.e, (-np.square(x)/(2*np.square(sigma))))
    return x

x = np.linspace(-5, 5, 100)
y = gauss(x, 1.0)
fig, ax = plt.subplots()
ax.plot(x, y)

"""## Part b
Use the above function to implement a function `gaussian_filter(image, sigma, padding)`, which first generates a Gaussian filter and then applies it to the `image`.
The size of the filter should be $2 \cdot \lceil 3 \sigma \rceil + 1$.
Remember that the Gaussian is separable, *i.e.* that an equivalent 2D result can be obtained through a sequence of two 1D filtering operations.
Do not use any existing implementation for convolution in this part (e.g. `scipy.ndimage.convolve`).
However, you are allowed to use these implementations in the following questions.
"""

#zero padding
def zero_padding(image, ker_w, ker_h):
    image_w, image_h, im_channels = image.shape
    res = np.zeros((image_w + ker_w, image_h + ker_h, im_channels))
    res[int(ker_w/2):int(ker_w/2 + image_w), int(ker_h/2):int(ker_w/2 + image_h)] = image

    return res

def gaussian_filter(image, sigma, padding=True):
    # Your code here
    im_w, im_h, im_channels = image.shape
    kernel_size = int(np.ceil(3*sigma))

    #create 2 1d gaussian filters and apply convolution with each other
    flt_1d_1 = np.arange(-kernel_size, kernel_size + 1)
    flt_1d_2 = np.arange(-kernel_size, kernel_size + 1)
    flt_1d_1 = gauss(flt_1d_1, sigma)
    flt_1d_2 = gauss(flt_1d_2, sigma)

    flt_gauss = np.outer(flt_1d_1, flt_1d_2)
    flt_gauss = flt_gauss / np.sum(flt_gauss)

    #pad the image
    image = zero_padding(image, 2*kernel_size, 2*kernel_size)

    #convolve with images
    res = np.zeros((im_w, im_h, im_channels))
    flt_gauss = np.flip(flt_gauss, 0)
    flt_gauss = np.flip(flt_gauss, 1)

    for i in range(im_w):
        for j in range(im_h):
            for ch in range(im_channels):
                x = image[i:i + 2*kernel_size + 1, j:j + 2*kernel_size + 1, ch]
                res[i,j,ch] = np.sum(image[i:i + 2*kernel_size + 1, j:j + 2*kernel_size + 1, ch] * flt_gauss)
        # print(f"Processing image row...{i}")
    res = res.astype("uint8")
    return res

"""Read the image ``graf_small.png`` and apply the filters with ``sigma = 2``, ``4``, and ``8``.
Again, choose the kernel size as $2 \cdot \lceil 3 \sigma\rceil + 1$.
What do you observe?
"""

image = imread_rgb('JoanofArc.jpg')
sigmas = [2, 4, 8]
# blurred_images = [gaussian_filter(image, s) for s in sigmas]
titles = [f'sigma={s}' for s in sigmas]

# plot_multiple(blurred_images, titles)
# plt.show()
# print("finished")

"""**What do you observe? Type your answer here:**

----

OpenCV has many built-in function for image smoothing.
Check out this page:
https://docs.opencv.org/3.1.0/d4/d13/tutorial_py_filtering.html

Compare the result of ``cv2.GaussianBlur`` with your own implementation by computing the difference image.
Was your implementation correct?
"""

def gauss_cv(image, sigma):
    ks = 2 * int(3 * sigma) + 1
    return cv2.GaussianBlur(image, (ks, ks), sigma, cv2.BORDER_DEFAULT)

def abs_diff(image1, image2):
    image1 = image1.astype(np.float32)
    image2 = image2.astype(np.float32)
    return np.mean(np.abs(image1-image2), axis=-1)

blurred_images_cv = [gauss_cv(image, s) for s in sigmas]
# differences = [abs_diff(x,y) for x, y in zip(blurred_images, blurred_images_cv)]
i = 0
for im in blurred_images_cv:
    cv2.imwrite(f'../data/result{i}.JPG', blurred_images_cv[i])
    i += 1
plot_multiple(blurred_images_cv, titles)
plt.show()
# plot_multiple(differences, titles)
# plt.show()

"""**Was your implementation correct? What do you observe? Type your answer here:**

----
"""

