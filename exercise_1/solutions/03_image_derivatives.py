# -*- coding: utf-8 -*-
"""03_image_derivatives.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SYCMt52FlYBIfmBcVyRou85q0NzR76QC

# Image Derivatives
This exercise introduces image derivative operators.
"""

# %matplotlib notebook
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
from scipy import ndimage

"""## Some Convenience Functions."""

def convolve_with_two(image, kernel1, kernel2):
    """Apply two filters, one after the other."""
    image = ndimage.convolve(image, kernel1)
    image = ndimage.convolve(image, kernel2)   
    return image

def imread_gray(filename):
    """Read grayscale image from our data directory."""
    return cv2.imread(f'../data/{filename}',
                      cv2.IMREAD_GRAYSCALE).astype(np.float32)

def plot_multiple(images, titles, colormap='gray',
                  max_columns=np.inf, share_axes=True):
    """Plot multiple images as subplots on a grid."""
    assert len(images) == len(titles)
    n_images = len(images)
    n_cols = min(max_columns, n_images)
    n_rows = int(np.ceil(n_images / n_cols))
    fig, axes = plt.subplots(
        n_rows, n_cols, figsize=(n_cols * 4, n_rows * 4),
        squeeze=False, sharex=share_axes, sharey=share_axes)

    axes = axes.flat
    # Hide subplots without content
    for ax in axes[n_images:]:
        ax.axis('off')
        
    if not isinstance(colormap, (list,tuple)):
        colormaps = [colormap]*n_images
    else:
        colormaps = colormap

    for ax, image, title, cmap in zip(axes, images, titles, colormaps):
        ax.imshow(image, cmap=cmap)
        ax.set_title(title)
        
    fig.tight_layout()

# From Question 1: Gaussian Filtering
def gauss(x, sigma):
    return 1.0 / np.sqrt(2.0 * np.pi) / sigma * np.exp(- x**2 / 2.0 / sigma**2)

"""## Part a
Implement a function for creating a Gaussian derivative filter in 1D according to the following equation

$$
\frac{d}{dx} G = \frac{d}{dx} \frac{1}{\sqrt{2\pi}\sigma} \operatorname{exp}\biggl(-\frac{x^2}{2\sigma^2}\biggr)
               = -\frac{1}{\sqrt{2\pi}\sigma^3}x \operatorname{exp}\biggl(-\frac{x^2}{2\sigma^2}\biggr)
$$

Your function should take a vector of integer values $x$ and the standard deviation ``sigma`` as arguments.
"""

def gaussdx(x, sigma):
    # Your code here
    # diff = np.array([[1, 0, -1]]) #diffrentiation filter
    # x = gauss(x, sigma)
    # x = ndimage.convolve(x, diff)
    x = - x / (np.sqrt(2 * np.pi) * np.power(sigma, 3)) * np.exp(- x**2 / (2 * sigma**2))
    return x

x = np.linspace(-5, 5, 100)[np.newaxis]
G = gauss(x, sigma=1.0)
y = gaussdx(x, sigma=1.0)
fig, ax = plt.subplots()
ax.plot(x[0], y[0])
plt.show()

"""The effect of applying a filter can be studied by observing its so-called *impulse response*.
For this, create a test image in which only the central pixel has a non-zero value (called an *impulse*):
"""

impulse = np.zeros((25, 25), dtype=np.float32)
impulse[12, 12] = 255

"""Now, create the following 1D filter kernels ``gaussian`` and ``derivative``."""

sigma = 6.0
kernel_radius = int(3.0 * sigma)
x = np.arange(-kernel_radius, kernel_radius + 1)[np.newaxis]
G = gauss(x, sigma)
D = gaussdx(x, sigma)
G_T = np.transpose(G)
D_T = np.transpose(D)

"""What happens when you apply the following filter combinations? 
(Hint: use ``convolve_with_two`` function at the beginning of this notebook.)

- first ``gaussian``, then ``gaussian^T``.
- first ``gaussian``, then ``derivative^T``.
- first ``derivative``, then ``gaussian^T``.
- first ``gaussian^T``, then ``derivative``.
- first ``derivative^T``, then ``gaussian``.

Display the result images with the `plot_multiple` function. Describe your result.
"""

# Modify this
images = [
    impulse,
    convolve_with_two(impulse, G, G_T),
    convolve_with_two(impulse, G, D_T),
    convolve_with_two(impulse, D, G_T),
    convolve_with_two(impulse, G_T, D),
    convolve_with_two(impulse, D_T, G),
    convolve_with_two(impulse, D, D_T),
    convolve_with_two(impulse, G, D),
    convolve_with_two(impulse, G_T, D_T)]

titles = [
    'original',
    'first G, then G^T',
    'first G, then D^T',
    'first D, then G^T',
    'first G^T, then D',
    'first D^T, then G',
    'first D, then D^T',
    'first G, then D',
    'first G^T, then D^T']

plot_multiple(images, titles, max_columns=3)
plt.show()

"""## Part b

Use the functions ``gauss`` and ``gaussdx`` directly in order to create a new function ``gauss_deriv`` that returns the 2D Gaussian derivatives of an input image in $x$ and $y$ direction.
"""


def gauss_derivs(image, sigma):
    # Your code here.
    kernel_size = int(3.0 * sigma)
    x = np.arange(-kernel_size, kernel_size + 1)[np.newaxis]
    G = gauss(x, sigma)
    G = np.flip(G, 0)

    D = gaussdx(x, sigma)
    D = np.flip(D, 0)

    image_dx, image_dy = convolve_with_two(image, np.transpose(G), D), convolve_with_two(image, G, np.transpose(D))
    return image_dx, image_dy

"""Try the function on the given example images and describe your results."""

image = imread_gray('tomatoes.png')
grad_dx, grad_dy = gauss_derivs(image, sigma=5.0)
plot_multiple([image, grad_dx, grad_dy], 
              ['Image', 'Derivative in x-direction', 'Derivative in y-direction'])
plt.show()

"""In a similar manner, create a new function ``gauss_second_derivs`` that returns the 2D second Gaussian derivatives $\frac{d^2}{dx^2}$, $\frac{d^2}{dx dy}$ and $\frac{d^2}{dy^2}$ of an input image."""

def gauss_second_derivs(image, sigma):
    # Your code here
    diff = np.array([[1, 0, -1]])
    diff = np.flip(diff, 0)
    # diffrentiation filter
    kernel_size = int(3.0 * sigma)
    x = np.arange(-kernel_size, kernel_size + 1)[np.newaxis]

    G = gauss(x, sigma)
    G = np.flip(G, 0)
    D = gaussdx(x, sigma)
    D = np.flip(D, 0)

    image_dx = convolve_with_two(image, np.transpose(G), D)
    image_dy = convolve_with_two(image, G, np.transpose(D))
    image_dxx = ndimage.convolve(image_dx, diff)
    image_dyy = ndimage.convolve(image_dy, np.transpose(diff))
    image_dxy = ndimage.convolve(image_dx, np.transpose(diff))
    # image_dxx, image_dxy, image_dyy = image, image, image
    return image_dxx, image_dxy, image_dyy

"""Try the function on the given example images and describe your results."""

image = imread_gray('coins1.jpg')
grad_dxx, grad_dxy, grad_dyy = gauss_second_derivs(image, sigma=2.0)
plot_multiple([image, grad_dxx, grad_dxy, grad_dyy],
              ['Image', 'Dxx', 'Dxy','Dyy'])

plt.show()

image = imread_gray('circuit.png')
grad_dxx, grad_dxy, grad_dyy = gauss_second_derivs(image, sigma=2.0)
plot_multiple([image, grad_dxx, grad_dxy, grad_dyy],
              ['Image', 'Dxx', 'Dxy','Dyy'])

plt.show()

"""**Briefly describe the results here:**

----

## Part c
Create a new function ``image_gradients_polar`` that returns two images with the magnitude and orientation of the gradient for each pixel of the input image.
"""

def image_gradients_polar(image, sigma):
    # Your code here
    kernel_size = int(3.0 * sigma)
    x = np.arange(-kernel_size, kernel_size + 1)[np.newaxis]
    #get 1d gaussian kernel and 1d dritive of gaussian
    G = gauss(x, sigma)
    G = np.flip(G, 0)
    D = gaussdx(x, sigma)
    D = np.flip(D, 0)

    #get x,y component of the gradient
    image_dx = convolve_with_two(image, np.transpose(G), D)
    image_dy = convolve_with_two(image, G, np.transpose(D))

    magnitude = np.sqrt(np.square(image_dx) + np.square(image_dy))
    direction = np.arctan2(image_dy, image_dx)

    return magnitude, direction

"""Try the function on the given example images and describe your results."""

image = imread_gray('coins1.jpg')
grad_mag, grad_dir = image_gradients_polar(image, sigma=2.0)

# Note: the twilight colormap only works since Matplotlib 3.0, use 'gray' in earlier versions.
plot_multiple([image, grad_mag, grad_dir], 
              ['Image', 'Magnitude', 'Direction'], 
              colormap=['gray', 'gray', 'twilight'])
plt.show()
image = imread_gray('circuit.png')
grad_mag, grad_theta = image_gradients_polar(image, sigma=2.0)
plot_multiple([image, grad_mag, grad_theta], 
              ['Image', 'Magnitude', 'Direction'],
              colormap=['gray', 'gray', 'twilight'])
plt.show()
"""**Briefly describe your results here:**
    
----

## Part d
Create a new function ``laplace`` that returns an image with the Laplacian-of-Gaussian for each pixel of the input image.
"""

def laplace(image, sigma):
    # Your code here
    image_dxx, _, image_dyy = gauss_second_derivs(image, sigma)
    lap = image_dxx + image_dyy
    return lap

"""Try the function on the given example images and describe your results."""

image = imread_gray('coins1.jpg')
lap = laplace(image, sigma=2.0)
plot_multiple([image, lap], ['Image', 'Laplace'])
plt.show()
image = imread_gray('circuit.png')
lap = laplace(image, sigma=2.0)
plot_multiple([image, lap], ['Image', 'Laplace'])
plt.show()
"""**Briefly describe your results here:**
    
----
"""