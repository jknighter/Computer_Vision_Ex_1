# -*- coding: utf-8 -*-
"""02_fourier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fuXg6IDrNdSC0iefPJ0zqEGertUGnd12

# Fourier transform

In this part, we look at the effect of filtering in Fourier space.

This gives us a different way of looking at images and yields deeper insights to what is going on when we apply a filter or downsample an image.
"""

# %matplotlib notebook
import matplotlib as mpl
import matplotlib.pyplot as plt
import scipy.signal
import numpy as np
from scipy import ndimage
import cv2

"""## Some convenience functions"""

def imread_gray(filename):
    """Read grayscale image from our data directory."""
    return cv2.imread(f'../data/{filename}',
                      cv2.IMREAD_GRAYSCALE).astype(np.float32)

def convolve_with_two(image, kernel1, kernel2):
    """Apply two filters, one after the other."""
    image = ndimage.convolve(image, kernel1, mode='wrap')
    image = ndimage.convolve(image, kernel2, mode='wrap')
    return image

def fourier_spectrum(im):
    normalized_im = im / np.sum(im)
    f = np.fft.fft2(normalized_im)  #compute 2-dimensional discrete fourier transform
    return np.fft.fftshift(f)

def log_magnitude_spectrum(im):
    return np.log(np.abs(fourier_spectrum(im))+1e-8)

def plot_with_spectra(images, titles):
    """Plots a list of images in the first column and the logarithm of their
    magnitude spectrum in the second column."""
    
    assert len(images) == len(titles)
    n_cols = 2
    n_rows = len(images)
    fig, axes = plt.subplots(
        n_rows, 2, figsize=(n_cols * 4, n_rows * 4),
        squeeze=False)

    spectra = [log_magnitude_spectrum(im) for im in images]

    lower = min(np.percentile(s, 0.1) for s in spectra)
    upper = min(np.percentile(s, 99.999) for s in spectra)
    normalizer = mpl.colors.Normalize(vmin=lower, vmax=upper)
    
    for ax, image, spectrum, title in zip(axes, images, spectra, titles):
        ax[0].imshow(image, cmap='gray')
        ax[0].set_title(title)
        ax[0].set_axis_off()
        c = ax[1].imshow(spectrum, norm=normalizer, cmap='viridis')
        ax[1].set_title('Log magnitude spectrum')
        ax[1].set_axis_off()
        
    fig.tight_layout()
    
def generate_pattern():
    x = np.linspace(0, 1, 256, endpoint=False)
    y = np.sin(x**2 * 16 * np.pi)
    return np.outer(y,y)/2+0.5

im_grass = imread_gray('grass.jpg')
im_zebras = imread_gray('zebras.jpg')
im_pattern = generate_pattern()

"""## Plotting demo
This is how you can load example images and plot the logarithm of its magnitude spectrum.

Low frequencies appear near the center and higher frequencies towards the outside.

Greener (lighter) colors mean higher values. The color scale is consistent within the subplots of a single plot, but may differ in different plots.
"""

plot_with_spectra([im_grass, im_zebras, im_pattern],
                  ['Grass image', 'Zebra image', 'Sine pattern'])
# plt.show()
"""## (a) Blurring

Consider one of the images (`im_grass` is a good choice).

### i)
Implement `filter_box(image, size)` that outputs the box-filtered version of `image`, using `convolve_with_two` (since the box filter is separable). The parameter `size` refers to the side length of the box filter.

### ii) 
Implement `filter_gauss(image, kernel_factor, sigma)` using `convolve_with_two`. The parameter `kernel_factor` defines the half size of the kernel relative to sigma (our rule of thumb from the lecture was to set this as 3).

Plot the image and its blurred versions (with the box and the Gauss filter) along with their spectra using `plot_with_spectra()`.

Vary the size of the box filter. What do you observe? For the Gaussian, change sigma.  What happens if you increase or decrease the `kernel_factor` compared to our rule-of-thumb value 3?
"""


def filter_gauss(image, kernel_factor, sigma):
    # gauss_1d = np.linspace(-kernel_factor, kernel_factor, 2*kernel_factor)
    # gauss_1d = 1 / (np.sqrt(2 * np.pi) * sigma) * np.power(np.e, (-np.square(gauss_1d) / (2 * np.square(sigma))))
    # image[:] = convolve_with_two(image[:], gauss_1d, gauss_1d)

    #generate gaussian kernel
    x, y = np.meshgrid(np.linspace(-1, 1, 2*kernel_factor), np.linspace(-1, 1, 2*kernel_factor))
    d = np.sqrt(x * x + y * y)
    #flt_gauss = ndimage.gaussian_filter(d, sigma)
    mean = 0
    flt_gauss = np.exp(-((d - mean) ** 2 / (2.0 * sigma ** 2)))
    image = convolve_with_two(image, flt_gauss, flt_gauss)
    return image


def filter_box(image, size):
    flt_box = (1/np.square(size))*np.ones((size, size))
    image = convolve_with_two(image, flt_box, flt_box)
    return image

im = im_grass
box_filtered = filter_box(im, 3)  # Change this
gauss_filtered = filter_gauss(im, 3, 1) # Change this

plot_with_spectra(
    [im, box_filtered, gauss_filtered],
    ['Image', 'Box filtered', 'Gauss filtered'])

plt.show()

"""## (b) Sampling and aliasing

### i)

Implement a function `sample_with_gaps(image, period)`, where `period` is an integer and defines the distance between two sampled points in pixels. The output should have the same size as `image` but have zeros everywhere except at the sampled points, where it should be equal to `image`. For example if `period=2` then every second row and every second column of the image should be zero in the output.

Using `sample_with_gaps`, sample the `im_zebras` image with a period of 2 pixels and plot the original and sampled images along with their spectra.

### ii)
Consider the image `im_pattern` and sample it with a period of 4, 8 and 16 and plot the resulting spectra. What happens as you increase the sampling period?
Now apply **Gaussian blurring** before sampling, with different sigma values. Approximately what sigma do you need for avoiding artifacts when `period=16`?

### iii)
Implement `sample_without_gaps(image, period)`, which is like `sample_with_gaps` but the output does not contain gaps (rows and columns of zeros) and therefore the output size is smaller. What effect do you see in the resulting magnitude spectrum, compared to `sample_with_gaps`?
"""

def sample_with_gaps(image, period):
    sampled_im = np.zeros(image.shape)
    sampled_im[0::period] = image[0::period]
    sampled_im[:, 0::period] = image[:, 0::period]

    return sampled_im

def sample_without_gaps(image, period):
    sampled_im = image[0::period, 0::period]

    return sampled_im

im = im_zebras
im = im_pattern

gap_sampled = sample_with_gaps(im, 2)
sampled = sample_without_gaps(im, 2)

plot_with_spectra(
    [im_zebras, gap_sampled, sampled],
    ['Image', 'Imaged sampled with gaps', 'Image sampled without gaps'])

plt.show()